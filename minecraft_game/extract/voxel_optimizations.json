{"extracted_information": "В статье описываются техники оптимизации воксельной сетки, используемые в игре Sector's Edge, для обеспечения высокой производительности при работе с большими разрушаемыми воксельными мирами. Основное внимание уделено оптимизации регенерации меша на CPU и управлению памятью. Целями являются быстрая регенерация меша с низким количеством треугольников и быстрая обработка вершин на GPU. Описан метод меширования, отличный от 'Greedy meshing', и детальные оптимизации на уровне кода, включая работу с массивами, распределение памяти и уменьшение нагрузки на сборщик мусора.", "specifications": {"структура_карты": {"разделение_на_чанки": "32 x 32 x 32 блока на чанк", "хранение_данных_блоков": "Массив Block[] data = new Block[CHUNK_SIZE_CUBED]; внутри каждого чанка. Block содержит byte kind (тип) и byte health (здоровье)", "размер_чанка": {"CHUNK_SIZE": 32, "CHUNK_SIZE_SQUARED": 1024, "CHUNK_SIZE_CUBED": 32768}}, "упаковка_вершин": {"формат_данных_вершины": "Каждая вершина упакована в один uint для снижения накладных расходов GPU", "поля": {"позиция_XYZ": "18 бит", "текстурный_юнит": "5 бит", "здоровье": "4 бита", "нормаль": "3 бита"}}}, "pricing": {}, "features": [{"категория": "Рендеринг/Меширование", "название": "Генерация сетки на основе 'прогонов'", "описание": "Блоки объединяются в 'прогоны' по осям X и Y. Для уменьшения количества треугольников, прогон не разбивается, если он покрыт блоком. Прогоны разбиваются только при изменении текстуры или повреждении следующего блока. Это позволяет регенерировать сетку чанка с меньшим количеством сравнений блоков, при этом объединяя грани для уменьшения количества треугольников.", "алгоритм_отличия_от_greedy_meshing": "Метод 'Greedy meshing' был отклонен из-за недостаточной скорости регенерации, несмотря на низкое количество треугольников, из-за большого числа сравнений блоков."}, {"категория": "Оптимизация производительности CPU", "название": "Inlining методов", "описание": "Использование атрибута `MethodImpl(MethodImplOptions.AggressiveInlining)` для всех методов, кроме `GenerateMesh`, привело к увеличению скорости на 3%."}, {"категория": "Оптимизация производительности CPU/Памяти", "название": "Предварительный расчет и использование ref locals", "описание": "Предварительный расчет общих операций (например, i+1, j+1, k+1, health/16). Использование `ref locals` для избежания копирования структур в стек и множественных обращений к массивам. Уменьшение количества побитовых операций с 24 до 19 на квад."}, {"категория": "Оптимизация производительности CPU", "название": "Ссылки на соседние чанки", "описание": "Хранение ссылок на соседние чанки в начале `GenerateMesh` позволило избежать 32*32 дорогостоящих вызовов функции `Map.IsNoBlock` с каждой стороны чанка, увеличив скорость на 10%."}, {"категория": "Оптимизация производительности CPU/Памяти", "название": "Одномерные массивы", "описание": "Переход от многомерных массивов (`Block[,,] data;`) к одномерным (`Block[] data;`) для данных блоков и массивов `ChunkHelper`. Прирост скорости на 20%. Компилятор оптимизирует умножения в побитовые сдвиги, так как размер чанка (32) является степенью двойки. Возможность предварительного расчета индекса одномерного массива."}, {"категория": "Управление памятью/Сборщик мусора", "название": "Оптимизация сборки мусора", "описание": "Использование `Array.Clear` вместо перевыделения массивов `ChunkHelper` при их сбросе, что снижает нагрузку на сборщик мусора. Прирост скорости на 10%."}, {"категория": "Управление памятью/Производительность", "название": "Прямая запись в буфер памяти", "описание": "Функция `AppendQuad` теперь принимает буфер вершин в качестве параметра и записывает данные непосредственно в него, вместо того чтобы возвращать массив `uint` и затем копировать его. Это устраняет множество дорогостоящих вызовов `Array.Copy`. Прирост скорости на 20%. Буфер расширяется функцией `Extend` по мере необходимости."}, {"категория": "Оптимизация производительности CPU", "название": "Оптимизированный доступ к блокам", "описание": "Приоритет прямого доступа к блокам внутри чанка, когда это возможно. Функция `IsNoBlock` в классе `Map` оптимизирована с использованием побитовых сдвигов и масок для быстрого доступа к чанкам и данным блоков по глобальным координатам."}], "statistics": {"бенчмаркинг_производительности": {"начальные_показатели": {"инициализировано_чанков": 807, "общее_время": "4158 мс", "среднее_время_на_чанк": "5.15 мс"}, "после_оптимизаций": {"инициализировано_чанков": 807, "общее_время": "722 мс", "среднее_время_на_чанк": "0.89 мс", "увеличение_скорости": "5.7x"}, "дальнейшие_оптимизации_в_другой_статье": {"снижение_времени_на_чанк": "до 0.48 мс"}}, "эффективность_оптимизаций": {"Inlining": "3% прирост скорости", "Pre-Calculating_and_Ref_Locals": "5% прирост скорости", "Neighbouring_Chunks": "10% прирост скорости", "Single-Dimensional_Arrays": "20% прирост скорости", "Garbage_Collection": "10% прирост скорости", "Memory": "20% прирост скорости", "Block_Access": "20% прирост скорости"}}, "temporal_info": {"дата_публикации": "Июль 2019 (для изображений)", "обновления_статьи": "Новая статья с дальнейшими оптимизациями, снижающими время инициализации чанка до 0.48 мс."}, "geographical_data": {}, "references": [{"тип": "исходный_код", "название": "GitHub", "ссылка": "https://github.com/Vercidium/voxel-mesh-generation"}, {"тип": "статья", "название": "Further Voxel World Optimisations", "ссылка": "https://vercidium.com/blog/further-voxel-world-optimisations/"}, {"тип": "игра", "название": "Sector's Edge", "ссылка": "https://sectorsedge.com"}, {"тип": "алгоритм", "название": "Greedy meshing", "ссылка": "https://0fps.net/2012/06/30/meshing-in-a-minecraft-game/"}, {"тип": "сообщество", "название": "Discord server Sector's Edge", "ссылка": "https://sectorsedge.com/discord"}, {"тип": "статья", "название": "3D Rendering Behind the Scenes", "ссылка": "https://vercidium.com/blog/3d-rendering-behind-the-scenes/"}]}